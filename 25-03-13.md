### Git을 배우면 할 수 있는 것들

- 커밋은 기본적으로 이전 커밋을 참조하는 것처럼 된다.
- 기획 변경에 유연하게 대응 가능하다.

### 소프트웨어 형상관리

SCM(Software Configuration Management)

소프트웨어 변경사항을 체계적으로 추적관리통제 하는 것

- Git은 VCS의 일종으로 형상관리의 한축을 담당

Q: 소프트웨어 형상관리 어떤 것 사용하시나요?, VCS 어떤 것 쓰시나요?

A: Git 사용중입니다.

### VCS - Version Control System

파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전으로 꺼내올 수 있는 시스템

CVCS vs DVCS

### CVCS(ex: SVC, CVS)

- 코드를 **중앙 집중식**으로 관리
    - 네트워크 연결이 없다면 관리X
- 커밋하면 바로 중앙 히스토리에 반영
- 중앙 히스토리만 존재
    - 자신만의 작업 히스토리 가질 수 없음
- **버전관리를 위해 대부분 연산을 서버에서 처리**
    - (36번까지 작업을 했는데 2번 작업을 보고 싶다면? 35, 34, 33, 32 순서대로 파일을 빼서 확인해야한다.)
- **Delta 방식**으로 데이터를 관리한다.

<aside>
💡

Delta 방식? - 파일의 변화를 체크하여 차이점을 인식해서 관리

따라서 용량을 효율적으로 저장한다.

대신 변화된 부분을 감지하기 위해서 연산이 오래 걸리게 된다.

</aside>

### DVCS - Distributed Version Control System

- 코드를 **분산**적으로 관리
    - 개발자 별 별도의 히스토리 관리 가능
    - 서버의 코드가 유실되어도 복구 가능
- 네트워크가 연결되어 있지 않아도 커밋 등 버전관리 가능
- 대부분의 **연산이 로컬에서 이루어지기** 때문에 매우 빠름
- **스탭샷** + 델타 방식으로 데이터를 관리

변화에 대한 모든 히스토리를 가지고 있기 때문에 용량을 되게 많이 가지고 있게 된다.

<aside>
💡

Snapshot 방식?

특정 시점의 파일과 디렉토리 상태를 그대로 사진찍듯 관리한다.

용량을 조금 더 많이 저장

</aside>

git: 스냅샷 기반으로 델타 관리.

commit 하나당 snapshot…을 찍는다. 약 10000개 넘어가면 그 이전 것은 델타방식으로 관리된다. 하지만 약 10000개와 같은 것은 git이 판단한다. 혹은 개발자가 지정할 수도 있다.

→ 용량과 속도를 효율적으로 잘 관리함.

### Git 이해하기

- 작업공간
- 파일상태
- 커밋
- 브랜치
- HEAD

우리의 프로젝트 파일에서 `.git` 이 local repository이다.

GitHub는 Remote Repository 중 하나이다.

100개 중에 50개만 임시적으로 올리고 싶다. → Staging Area(add를 통해)

### Git의 작업 공간

- Working Directory
    - 현재 내 코드가 저장된 공간
    - Git init을 통해 git 관리를 시작.
    - 이후에 배울 커밋/브랜치 시점에 따라 . 내작업공간의 상태가 변화
    

- Staging Area(indx)
    - 커밋을 위한 장바구니 / 다음 커밋의 스냅샷을 위한 밑바당
    - 작업 과정에서 중간 산출물을 적절하게 선택하여 커밋
    - Conflict가 일어났을 때, 임시 상태의 데이터를 관리하는 공간
    - Staging Area가 없으면 메모리 상으로 관리해야함

- Local Repository
    - 파일 변경 이력인 커밋이 보관되는 ‘로컬’공간
    - 내부적으로 각종 로그들이 보관되어 git을 지탱

- Remote Repository
    - 파일 변경 이력인 커밋이 보관되는 ‘리모트’공간
    - 내부적으로 각종 로그들이 보관되어 git을 지탱

### Git에서 관리하는 파일 상태

- Untracked
- Tracked
- Modified

### Git Add의 특징

- Add를 통해 수정이 발생한 파일을 Staging Area로 이동할 수 있음
- 수정이 발생한 파일이 없다면, ADD되는 파일도 없음

### Git Commit 알아보기

Staging Area → Local Repository

16Bit 문자열로 40자리로 Commit 해쉬 아이디가 이루어져있다.

- 커밋 정보
    - 작성자, 작성일자
    - 커밋메시지
    - 커밋ID
    - 변경이력
    - Parents commit
    - Etc

- Staging Area에 Index된 변화를 커밋을 통해 히스토리화
- Root commit을 제외한 커밋들은 Parents commit을 가짐
- 현재 커밋의 이전 커밋이 Parents commit

즉, 현재 커밋이 이전 커밋의 ID를 들고 있는다.

<특정 커밋에 변화가 발생하면, 이후 모든 커밋에 변화가 발생>

만약, 1, 2, 3, 4, 5 컴밋에서 3번 커밋을 수정하게 된다면? 뒤에있는 4, 5의 커밋 ID가 모두 바뀐다.

**커밋 아이디는 어떻게 만들어지나?**

- 변화된 값과 커밋 정보를 기반으로 SHA-1 알고리즘 해싱
- 커밋 아이디 자체가 git 무결성을 위한 체크섬
- 160bit: 40자리 16진수 값으로 이루어짐.

**Hashing?**

한글자를 SHA-1해싱하더라도 → 40자, 500자를 SHA-1 해싱하더라도 → 40자

같은 값은 무조건 동일한 해싱이 나온다. (Input이 같으면 Output은 같음. Input이 조금만 달라져도 엄청나게 다른 값이 Output이 나온다)

**단방향 암호화이다. 변화된 값으로 원래 값을 유추할 수 없다.**

Commit은 항상 정상 동작을 보장하는 경우에만 커밋

Amend commit

- 이전 커밋에 overriding할 수 있다.

### Git Branch 이해하기

- Branch 독립적인 작업공간을 생성하는 개념
- 작업한 것을 이제 merge하여 덮어쓰기하는 방식으로 동작한다.

Head 위치가 어디에 있는지에 따라 나의 Working Directory가 달라진다.

HEAD에 따라 브랜치가 바뀐다.. HEAD는 여러 브랜치 중에 하나를 알아보고 있다.

- 브랜치는 커밋의 끝점을 가리키고있는 포인터이다.
- Branch의 변경은 HEAD의 변경과 해당 커밋을 바라보는 포인터이다..!
- Branch는 포인터이다. 내가 main 브랜치를 지우면 파일이 지워질까? 아니다. Branch를 지우면 포인터가 지워지는 것이다. 해당 방향으로 갈 수 없는 것이다.

스위치: 브랜치 전환

- 브랜치 변경(스위치) → 작업공간의 전환
- Branch를 변경한다는 것은 HEAD의 이동이다.

<aside>
💡

브랜치는 커밋을 가리키는 포인터

HEAD는 브랜치를 가리키는 포인터

항상 브랜치의 최신 커밋을 가르킨다.

</aside>

### HEAD 이해하기

Detached HEAD - 브랜치가 아닌 특정 커밋을 가르키는 경우 (개발자가 의도적으로 옮기는 것 일반적으로는 HEAD는 브랜치를 따라간다)

예를들어 패키지가 현재 6버전인데 이미 ignore되었다면, HEAD를 과거로 이동한 순간 2버전으로 바뀌어버린다.

이때, 다시 원래로 돌아오게 된다면 2버전으로 바뀌어버리고, ignore가 되었기 때문에 6버전으로 돌아갈 수 없다.

- 특정 브랜치나 커밋을 가르키는 포인터
    - 브랜치와 함꼐하며, 해당 브랜치의 최신 커밋을 가르킨다.
- HEAD가 가르키는 커밋위치에 따라 work drectory영향
- Detached HEAD
    - 과거 시점의 코드를 확인하거나
    - 과거 시점에서 브랜치를 생성해야 할 때
- 새로운 커밋이 생성된 경우 새로운 커밋을 가르킴
- HEAD의 변경을 git 내부에서 log로 관리

### Reset 이해하기

Reset: 특정 과거시점으로 돌아가기

Pointer를 해당 시점으로 이동한다. (커밋들이 삭제되지는 않는다)

```swift
git reset - soft
git reset - mixed
git reset - hard
```

git은 추가를 통해 삭제를 표현한다.

그래서 다시 이전의 포인터로 이동하면 살아난다. (git reflog - 한번이라도 생성된 커밋 확인 가능. 해당 commit으로 다시 reset하면 돌아갈 수 있다.)

Revert: 특정 과거 시점으로 돌아가기
