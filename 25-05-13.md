오늘은 자료구조 복습하기 !!

### 리스트

`순서`를 가지고 “일렬”로 나열한 원소들의 모임

종류

- Array
- ArrayList
- LinkedList

### Array

`연속된 메모리 공간`에 순차적으로 저장되는 자료구죠

= 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조

임의의 N번째 원소에 확인 / 수정 = O(1)

→ `Random Access`

어떤 문제점 ?!

최초 선언 시점에 크기가 고정되어있다.

### LinkedList

`연속되지 않은 메모리 공간`에 연결되어 저장되는 자료구조

### Stack

한 쪽 끝에서만 자료를 넣고 뺄 수 있는 FIFO, FILO 형식의 자료구조

- “~쌍”을 묻는 경우
- 자신보다 처음으로 큰, 작은 원소를 찾는 경우

### 재귀 함수

함수에서 자기자신을 다시 호출해서 작업을 수행하는 함수

→ 함수 종료 조건 Base Condition을 작성해야한다.

### Queue

먼저 들어간 데이터가 먼저 나오는 FIFO 형식의 자료구조

- Array
    - 첫번째 원소 빼는 것이 O(n)의 시간 복잡도가 발생한다.
- Array + Pointer
    - 메모리 공간을 계속해서 잡아먹게 된다.
- Array + Pointer + Circular
    - 한정된 메모리 공간만 사용할 수 있다.
- Linked List
    - 모든 것의 장점이 있지만 참조 지역성의 원리로 인해 Array가 오히려 빠를 수 있다.

### 참조 지역성

짧은 시간 동안 동일한 메모리 위치 집합에 반복적으로 접근하는 경향

### 해시 테이블

key에 대응되는 value값을 저장하는 자료구조

- 해시 함수를 이용해서 메모리 공간을 차지를 줄일 수 있다.
- 동일한 해시 값이 나오면 충돌이 발생할 수 있다.

### 충돌 회피 기법

- Chaining
    - 충돌이 발생하면 연결 리스트를 활용한다.
- Open Addressing
    - 충돌이 발생하면 다른 버킷을 찾아 데이터를 저장한다.
    - Swift는 Linear probing이다.

→ Load Factor가 커질 경우 버킷의 개수를 늘려주는 Resize과정을 한다.

→ 해시 함수의 특성 - 해시 함수는 충돌을 최소화 하기 위해 균등한 분포로 매핑할 수 있도록 설계되었다.

### 정렬

### Stable

정렬을 했을 때 같은 같을 가진 원소들의 순서가 유지되는 것

→ 정렬 결과가 항상 일정

### In-Place

원소의 개수에 비해 충분히 무시할만한 공간을 더 사용

→ Cache Hit Rate가 더 높다.

### 비선형 알고리즘

### 선형 vs 비선형

선형: 자료들간 앞 뒤 관계가 1 : 1

비선형: 자료들간 앞 뒤 관계가 1 : N or N : N
