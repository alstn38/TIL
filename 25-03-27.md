### 알고리즘 문제 중

```swift
/// 시간복잡도를 작성하고 어떤 값을 Return하고 있는지도 확인해보세요 :)
/// - Parameter n: 1이상의 정수
/// - Complexity: O(n), 3
/// - Returns: 2의 거듭제곱인 경우에는 true, 아닌 경우에는 false를 반환
func question3(_ n: Int) -> Bool {
  n & (n - 1) == 0
}
```

### 거듭제곱 / 지수

2^x라고 있을 때, 2는 밑 x는 지수이다.

### 로그

어떤 수를 나타내기 위해 밑을 몇번 거듭제곱해야하는가?

### 코딩테스트 체점

1억번연산이 1초라고 가정한다.

512MB = 0.6 * 10 ^ 8 개의 Int 64 (약 육천만개) 메모리.

### 리스트

`순서`를 가지고 `일렬`로 나열한 원소들의 모임

### Array

연속된 메모리 공간에 순차적으로 저장되는 자료구조

= 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조

임의의 N번째 원소에 확인 / 수정 = O(1)

→ `Random Access`

### 배열의 메서드

- 임의의 N번째 원소 확인 / 수정  = O(1)
- 임의의 N번째 원소 추가 = O(n)
- 임의의 N번째 원소 제거 = O(n)
- 배열의 마지막에 원소 추가 = O(1)
- 배열의 마지막 우너소 제거 = O(1)

**임의의 원소 접근 / 수정 = O(1)**

임의의 원소 추가 / 삭제 = O(n)

마지막 원소 추가 = O(1)

마지막 원소 삭제 = O(1)

**배열의 제약조건**

- 최초 선언 시점에 배열의 크기가 고정

### ArrayList (동적배열) - Swift 기본 제공 배열

미리 할당된 메모리보다 더 추가해야할 경우 다시 재할당을 하게 되는데 이렇게 재할당을 하는 메모리의 크기 기준은 언어마다 다르다.

그래서 재할당이 일어날때 복사를 해줘야하기 때문에 append시 O(n)의 시간 복잡도 만큼 시간이 걸릴 수 있다.

연속된 메모리 공간에 순차적으로 저장되는 자료구조

- Capacity를 통해 메모리 공간을 늘리는 구조

<aside>
💡

### Array에 대한 Tip

- `reserveCapacity()` 메서드를 이용하여 미리 많은 공간을 다시 할당시켜서 사용할 수도 있다.
- Array를 비우는 과정에서 `removeAll(keepCapacity:)` 메서드를 이용하여 메모리 공간을 유지시켜서 사용할 수도 있다.
</aside>

### LindedList(연결리스트)

`연속되지 않은` 메모리 공간에 연결되어 저장되는 자료구조

배열에서 발생되었던 메모리 낭비에 대한 문제가 발생하지 않는다.

연속된 메모리 공간에 존재하지 않기 때문에 조회를 바로 할 수 없다.

→ 임의의 N번째 원소에 대한 확인 / 수정

O(n)

임의의 N번째 원소 추가

벽걸이형 에어컨(원룸에 있는 일반적인 에어컨)은 작업시간이 얼마나정도 되나요?

O(n) + O(1)

임의의 N번째 원소 제거

O(n) + O(1)

만약 head와 tail을 알고 있는 경우에는

첫번째, 마지막 원소 추가 / 제거

O(1)

<aside>
💡

**특정 위치를 알고 있는 경우 삽입 / 삭제가 배열보다 빠르다.**

</aside>

현재 지금 커서가 가르키고 있는 위치는 빈번하게 추가되고 삭제되는데.. 

이것이 바로 커서를 통해서 위치를 바로 알고있기 때문에 이것이 바로 linkedLIst로 이루어져있다.

이것이 바로 text Editor가 linkeLIst에서 자주 사용되는 것의 대표적인 예시이다.

즉, 핵심은 삽입하고 삭제하는 위치를 알고있기 때문에 연산속도가 빠른 장점을 가져갈 수 있다.

정리

| method | Array | ArrayList | LinkedList |
| --- | --- | --- | --- |
| 임의의 원소 접근 / 수정 | O(1) | O(1) | O(n) |
| 임의의 원소 추가 / 삭제 | O(n) | O(n) | O(n) + O(1) |
| 마지막 원소 추가 | O(1) | Average, O(1) | O(1) |
| 마지막 원소 삭제 | O(1) | O(1) | O(1) |
