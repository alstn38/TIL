### HTTP 0.9

- GET 명령어만 있다.
- Header가 필요없다.
- StatusCode 없다.

### HTTP 1.0

- Post / Put 등장
- Header가 필요함
- StatusCode 등장
- 1요청마다 1TCP연결을 한다. → 네트워크 과부하
- 한번 요청을 보내고 그것에 대한 응답을 받지 않으면 다음 요청을 보내지 못했다.

### HTTP 1.1

- 1번의 TCP연결로 여러 통신 요청이 가능하다.
- 응답값이 오지 않아도 계속 요청을 보낼 수 있다. Keep-alive
- 하지만 응답순서는 순서대로 온다. (첫번째 응답을 받지 않으면 두번째 응답을 받지 않는다.)
    - 첫번째 응답이 10초 걸린다면 두번째는 1초걸린다고 하더라도, 두번째 응답을 받을 때 11초가 걸린다.
- 그렇기 때문에 크롬이나, 브라우저에서 TCP를 여러개 열어서 처리한다. (예를들어 6개의 TCP를 동시에 열어버린다)
    - 순서가 보장되지 않는다. 예를들어 이미지 순서와 같은 경우는 순서가 맞지 않을 수도 있다. 그러면 그냥 TCP 1개만 열 수도 있다.
- URLSession도 TCP를 6개를 열어버린다. (TCP 개수 조절 가능)
- persistance… PipeLine..
- 헤더가 너무 크다.

### HTTP 2.0

- 헤더를 경량화 하자. (바이너리 트레이밍)
- 첫번째 응답이 오지 않더라도 두번째 응답을 받을 수 있다. (스트림 다중화)
- HOLB 문제. (결국 패킷을 TCP에서 기다려야함)

### HTTP 3.0

- UDP위에서 동작.
- QUIC를 이제 표준으로 하려고한다..

### 암호화

- 단방향
    - 본질은 무결성에 대한 검증.
    - SHA 알고리즘
    - 복호화 X
- 양방향
    - 대칭키 (AES)
    - 비대칭키 (RSA)

E2EE (텔레그램)

### DNS

- naver 접속할 건데 IP 주소가 뭐야?라고 하면 알려준다.

new.naver.com

com - 1차 도메인이라고 한다.

TLD는 아마 전 세계에 (13대이다)

순서 확인해보기

1. 클라이언트가 Local DNS(대부분 통신사가 제공)에 naver 접속을 요청한다.
    - Local DNS가 naver 주소를 갖고 있다면 IP를 바로 return한다.
2. 만약 없다면 TLD에 물어본다. 너 혹시 naver있어? (1차 도메인 .com에 물어본다. naver.com이라고 알아?)
3. 만약 없다면? 다시 2차 도메인(.naver) 서버에 물어본다.. 또 없다면 3차(.new, news 등)로.. 등등.

만약 불법사이트를 막고 싶다면 DNS에서 막으면 된다.

TTL - 도메인 주소의 생명주기. (내가 등록한 도메인이 어느정도 가지고 있을 것이냐)
